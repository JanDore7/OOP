__dict__ - показывает все атрибуты класса, но не показывает атрибуты экземпляра класса если они не были созданы.
Экземпляры класса при создании не содержат своих собственных атрибутов они ссылаются на атрибуты класса.
	
isinstance(a, Point) - это проверка того, является ли объект a экземпляром класса Point или его подкласса. Это используется в Python для определения принадлежности объекта к определенному классу или его подклассам.


setattr(Класс или атрибут класса, название атрибута, значение) добавляет атрибут классу или экземпляру класса, или изменяет его значение если он уже существует.


getattr(Point, 'a', False) проверяет есть ли такой атрибут и возвращает его значение, если атрибут не существует, возвращает в данном случае False, но может и любое другое указанное значение


hasattr(Point, 'atribut') Возвращает булевое значение, в случае если атрибут существует, вернет True если нет False. Важно функция через пространство имен атрибута класса может обратиться к пространству имен самого класса. Т.е сам экземпляр класса может не иметь своего атрибута, иными словами a.__dict__ не будт содержать запрашиваемый атрибут, но функция все равно вернет True поскольку атрибут есть в Point.__dict__


delattr(Point, 'atribut') если атрибут отсутствует - упадет в ошибку если есть удалит его. Удаление происходит непосредственно в текущем пространстве имен.


class Point:
    color = 'red'
    circle = 2

    def set_coords(self):
        print(f'Вызов метода set_coords = {self=}')
        
#self = это ссылка на экземпляр класса иными словами в нашем премере сейчас
self = pt

pt = Point()
pt.set_coords() - сработает
Point.set_coords() - не сработает, потому что ждет аргумент  в виде экземпляра класса, т.е self.


Имена методов в классах - это тоже атрибуты


__new__ - вызывается перед созданием объекта класса


class Point:
    def __new__(cls, *args, **kwargs):
        print(f'вызов __new__ для {str(cls)}')

    def __init__(self, x=0, y=0):
        print(f'вызов __init__ для {self}')
        self.x = x
        self.y = y



В __new__ обязательный параметр cls это ссылка на текущий экземпляр класса 
в данном случае на Point, а в __init__ self ссылается на создаваемый экземпляр класса


Метод __new__ должен возвращать адрес нового созданного объекта.
return super().__new__(cls)
Базавый класс это object все классы всегда наследуются от него.


Паттерн Singelton - пример использования метода __new__ ситуация когда не должен создаваться новый экземпляр класса. А все новые длжны ссылаться на один уже иеющийся адрес

Если предполагается работа только с атрибутами класса, то используем   @classmethod
Сервисная функция это @staticmethod







